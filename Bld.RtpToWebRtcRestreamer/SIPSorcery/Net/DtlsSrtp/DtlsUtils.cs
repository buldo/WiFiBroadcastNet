//-----------------------------------------------------------------------------
// Filename: DtlsUtils.cs
//
// Description: This class provides useful functions to handle certificate in
// DTLS-SRTP.
//
// Notes: The webrtc specification provides guidelines for X509 certificate
// management:
// https://www.w3.org/TR/webrtc/#certificate-management
//
// In particular:
// "The explicit certificate management functions provided here are optional.
// If an application does not provide the certificates configuration option
// when constructing an RTCPeerConnection a new set of certificates MUST be
// generated by the user agent. That set MUST include an ECDSA certificate with
// a private key on the P-256 curve and a signature with a SHA-256 hash."
//
// Based on the above it's likely the safest algorithm to use is ECDSA rather
// than RSA (which will then result in an ECDH rather than DH exchange to
// initialise the SRTP keying material).
// https://www.w3.org/TR/WebCryptoAPI/#algorithms
//
// The recommended ECDSA curves are listed at:
// https://www.w3.org/TR/WebCryptoAPI/#ecdsa
// and are:
// - P-256, also known as secp256r1.
// - P-384, also known as secp384r1.
// - P-521, also known as secp521r1.
//
// TODO: Switch the self-signed certificates generated in this class to use
// ECDSA instead of RSA.
//
// Author(s):
// Rafael Soares (raf.csoares@kyubinteractive.com)
//
// History:
// 01 Jul 2020	Rafael Soares   Created.
//
// License:
// BSD 3-Clause "New" or "Revised" License, see included LICENSE.md file.
//-----------------------------------------------------------------------------

using Bld.RtpToWebRtcRestreamer.SIPSorcery.Net.WebRTC;
using Bld.RtpToWebRtcRestreamer.SIPSorcery.Sys;
using Org.BouncyCastle.Asn1;
using Org.BouncyCastle.Asn1.X509;
using Org.BouncyCastle.Bcpg;
using Org.BouncyCastle.Crypto;
using Org.BouncyCastle.Crypto.Generators;
using Org.BouncyCastle.Crypto.Operators;
using Org.BouncyCastle.Crypto.Prng;
using Org.BouncyCastle.Math;
using Org.BouncyCastle.Security;
using Org.BouncyCastle.Tls;
using Org.BouncyCastle.Tls.Crypto;
using Org.BouncyCastle.Tls.Crypto.Impl.BC;
using Org.BouncyCastle.Utilities;
using Org.BouncyCastle.X509;

namespace Bld.RtpToWebRtcRestreamer.SIPSorcery.Net.DtlsSrtp;

internal static class DtlsUtils
{
    /// <summary>
    /// The key size when generating random keys for self signed certificates.
    /// </summary>
    private const int DefaultKeySize = 2048;

    public static RTCDtlsFingerprint Fingerprint(string hashAlgorithm, Certificate certificate)
    {
        if (!IsHashSupported(hashAlgorithm))
        {
            throw new ApplicationException($"Hash algorithm {hashAlgorithm} is not supported for DTLS fingerprints.");
        }

        var digestAlgorithm = DigestUtilities.GetDigest(hashAlgorithm);
        var der = certificate.GetCertificateEntryAt(0).Certificate.GetEncoded();
        var hash = DigestOf(digestAlgorithm, der);

        return new RTCDtlsFingerprint
        {
            algorithm = digestAlgorithm.AlgorithmName.ToLower(),
            value = hash.AsSpan().HexStr(':')
        };
    }

    public static RTCDtlsFingerprint Fingerprint(Certificate certificateChain)
    {
        var certificate = certificateChain.GetCertificateAt(0);
        return Fingerprint(certificate);
    }

    private static RTCDtlsFingerprint Fingerprint(TlsCertificate c)
    {
        var sha256 = DigestUtilities.GetDigest(HashAlgorithmTag.Sha256.ToString());
        var der = c.GetEncoded();
        var sha256Hash = DigestOf(sha256, der);

        return new RTCDtlsFingerprint
        {
            algorithm = sha256.AlgorithmName.ToLower(),
            value = sha256Hash.AsSpan().HexStr(':')
        };
    }

    private static byte[] DigestOf(IDigest dAlg, byte[] input)
    {
        dAlg.BlockUpdate(input, 0, input.Length);
        var result = new byte[dAlg.GetDigestSize()];
        dAlg.DoFinal(result, 0);
        return result;
    }

    public static TlsCredentialedDecryptor LoadEncryptionCredentials(
        TlsContext context, Certificate certificate, AsymmetricKeyParameter privateKey)
    {
        return new BcDefaultTlsCredentialedDecryptor((BcTlsCrypto)context.Crypto, certificate,
            privateKey);
    }

    public static TlsCredentialedSigner LoadSignerCredentials(TlsContext context,
        Certificate certificate, AsymmetricKeyParameter privateKey,
        SignatureAndHashAlgorithm signatureAndHashAlgorithm)
    {
        return new BcDefaultTlsCredentialedSigner(
            new TlsCryptoParameters(context),
            (BcTlsCrypto)context.Crypto,
            privateKey,
            certificate,
            signatureAndHashAlgorithm);
    }

    public static TlsCredentials LoadSignerCredentials(
        TlsContext context,
        IList<SignatureAndHashAlgorithm> supportedSignatureAlgorithms,
        short signatureAlgorithm,
        Certificate certificate,
        AsymmetricKeyParameter privateKey)
    {
        /*
         * TODO Note that this code fails to provide default value for the client supported
         * algorithms if it wasn't sent.
         */

        SignatureAndHashAlgorithm signatureAndHashAlgorithm = null;
        if (supportedSignatureAlgorithms != null)
        {
            foreach (var alg in supportedSignatureAlgorithms)
            {
                if (alg.Signature == signatureAlgorithm)
                {
                    signatureAndHashAlgorithm = alg;
                    break;
                }
            }

            if (signatureAndHashAlgorithm == null)
            {
                return null;
            }
        }

        return LoadSignerCredentials(context, certificate, privateKey, signatureAndHashAlgorithm);
    }

    #region Self Signed Utils

    private static (X509Certificate certificate, AsymmetricKeyParameter privateKey) CreateSelfSignedBouncyCastleCert(string subjectName, string issuerName, AsymmetricKeyParameter issuerPrivateKey)
    {
        const int keyStrength = DefaultKeySize;
        if (issuerPrivateKey == null)
        {
            issuerPrivateKey = CreatePrivateKeyResource();
        }

        // Generating Random Numbers
        var randomGenerator = new CryptoApiRandomGenerator();
        var random = new SecureRandom(randomGenerator);
        ISignatureFactory signatureFactory = new Asn1SignatureFactory("SHA256WITHRSA", issuerPrivateKey, random);

        // The Certificate Generator
        var certificateGenerator = new X509V3CertificateGenerator();
        certificateGenerator.AddExtension(X509Extensions.SubjectAlternativeName, false, new GeneralNames(new[] { new GeneralName(GeneralName.DnsName, "localhost"), new GeneralName(GeneralName.DnsName, "127.0.0.1") }));
        certificateGenerator.AddExtension(X509Extensions.ExtendedKeyUsage, true, new ExtendedKeyUsage(new List<DerObjectIdentifier> { new("1.3.6.1.5.5.7.3.1") }));

        // Serial Number
        var serialNumber = BigIntegers.CreateRandomInRange(BigInteger.One, BigInteger.ValueOf(long.MaxValue), random);
        certificateGenerator.SetSerialNumber(serialNumber);

        // Issuer and Subject Name
        var subjectDn = new X509Name(subjectName);
        var issuerDn = new X509Name(issuerName);
        certificateGenerator.SetIssuerDN(issuerDn);
        certificateGenerator.SetSubjectDN(subjectDn);

        // Valid For
        var notBefore = DateTime.UtcNow.Date;
        var notAfter = notBefore.AddYears(70);

        certificateGenerator.SetNotBefore(notBefore);
        certificateGenerator.SetNotAfter(notAfter);

        // Subject Public Key
        var keyGenerationParameters = new KeyGenerationParameters(random, keyStrength);
        var keyPairGenerator = new RsaKeyPairGenerator();
        keyPairGenerator.Init(keyGenerationParameters);
        var subjectKeyPair = keyPairGenerator.GenerateKeyPair();

        certificateGenerator.SetPublicKey(subjectKeyPair.Public);

        // self sign certificate
        var certificate = certificateGenerator.Generate(signatureFactory);

        return (certificate, subjectKeyPair.Private);
    }

    public static (Certificate certificate, AsymmetricKeyParameter privateKey) CreateSelfSignedTlsCert(
        ProtocolVersion protocolVersion,
        TlsCrypto tlsCrypto)
    {
        return CreateSelfSignedTlsCert("CN=localhost", "CN=root", null, protocolVersion, tlsCrypto);
    }

    private static (Certificate certificate, AsymmetricKeyParameter privateKey) CreateSelfSignedTlsCert(
        string subjectName,
        string issuerName,
        AsymmetricKeyParameter issuerPrivateKey,
        ProtocolVersion protocolVersion,
        TlsCrypto tlsCrypto)
    {
        var tuple = CreateSelfSignedBouncyCastleCert(subjectName, issuerName, issuerPrivateKey);
        var certificate = tuple.certificate;
        var privateKey = tuple.privateKey;
        var tlsCertificate = LoadCertificateChain(protocolVersion, tlsCrypto,
            new List<byte[]> { certificate.GetEncoded() });
        return (tlsCertificate, privateKey);
    }

    private static AsymmetricKeyParameter CreatePrivateKeyResource()
    {
        const int keyStrength = DefaultKeySize;

        // Generating Random Numbers
        var randomGenerator = new CryptoApiRandomGenerator();
        var random = new SecureRandom(randomGenerator);

        // The Certificate Generator
        //var certificateGenerator = new X509V3CertificateGenerator();

        //// Serial Number
        //var serialNumber = BigIntegers.CreateRandomInRange(BigInteger.One, BigInteger.ValueOf(long.MaxValue), random);
        //certificateGenerator.SetSerialNumber(serialNumber);

        //// Issuer and Subject Name
        //var subjectDn = new X509Name(subjectName);
        //var issuerDn = subjectDn;
        //certificateGenerator.SetIssuerDN(issuerDn);
        //certificateGenerator.SetSubjectDN(subjectDn);

        //// Valid For
        //var notBefore = DateTime.UtcNow.Date;
        //var notAfter = notBefore.AddYears(70);

        //certificateGenerator.SetNotBefore(notBefore);
        //certificateGenerator.SetNotAfter(notAfter);

        // Subject Public Key
        var keyGenerationParameters = new KeyGenerationParameters(random, keyStrength);
        var keyPairGenerator = new RsaKeyPairGenerator();
        keyPairGenerator.Init(keyGenerationParameters);
        var subjectKeyPair = keyPairGenerator.GenerateKeyPair();

        return subjectKeyPair.Private;
    }

    #endregion

    /// <summary>
    /// Verifies the hash algorithm is supported by the utility functions in this class.
    /// </summary>
    /// <param name="hashAlgorithm">The hash algorithm to check.</param>
    public static bool IsHashSupported(string hashAlgorithm)
    {
        switch (hashAlgorithm.ToLower())
        {
            case "sha1":
            case "sha-1":
            case "sha256":
            case "sha-256":
            case "sha384":
            case "sha-384":
            case "sha512":
            case "sha-512":
                return true;
            default:
                return false;
        }
    }

    private static Certificate LoadCertificateChain(
        ProtocolVersion protocolVersion,
        TlsCrypto crypto,
        List<byte[]> resources)
    {
        if (TlsUtilities.IsTlsV13(protocolVersion))
        {
            var certificateEntryList = new CertificateEntry[resources.Count];
            for (var i = 0; i < resources.Count; ++i)
            {
                var certificate = LoadCertificateResource(crypto, resources[i]);

                // TODO[tls13] Add possibility of specifying e.g. CertificateStatus
                certificateEntryList[i] = new CertificateEntry(certificate, null);
            }

            // TODO[tls13] Support for non-empty request context
            var certificateRequestContext = TlsUtilities.EmptyBytes;

            return new Certificate(certificateRequestContext, certificateEntryList);
        }

        var chain = new TlsCertificate[resources.Count];
        for (var i = 0; i < resources.Count; ++i)
        {
            chain[i] = LoadCertificateResource(crypto, resources[i]);
        }
        return new Certificate(chain);
    }

    private static TlsCertificate LoadCertificateResource(TlsCrypto crypto, byte[] resource)
    {
        return crypto.CreateCertificate(resource);
    }
}